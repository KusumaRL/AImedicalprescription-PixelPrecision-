# ==================== DEPLOYMENT AND DEBUGGING SCRIPT ====================
# Save as debug_and_run.py

import subprocess
import sys
import time
import threading
import webbrowser
import os
from pathlib import Path
import logging
import signal

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class SystemManager:
    def __init__(self):
        self.backend_process = None
        self.frontend_process = None
        self.running = True

    def check_dependencies(self):
        """Check if required dependencies are installed"""
        required_packages = ['fastapi', 'uvicorn', 'streamlit', 'requests', 'pandas', 'plotly', 'pydantic']
        missing_packages = []

        for package in required_packages:
            try:
                __import__(package)
                logger.info(f"‚úÖ {package} is installed")
            except ImportError:
                missing_packages.append(package)
                logger.warning(f"‚ùå {package} is missing")

        if missing_packages:
            logger.info("Installing missing packages...")
            try:
                subprocess.check_call([
                    sys.executable, "-m", "pip", "install",
                    *missing_packages
                ])
                logger.info("‚úÖ All dependencies installed successfully")
                return True
            except subprocess.CalledProcessError as e:
                logger.error(f"‚ùå Failed to install dependencies: {e}")
                return False
        return True

    def check_files(self):
        """Check if required files exist"""
        files_to_check = [
            ("main.py", "Backend FastAPI application"),
            ("app.py", "Frontend Streamlit application")
        ]

        missing_files = []
        for filename, description in files_to_check:
            if Path(filename).exists():
                logger.info(f"‚úÖ {filename} found ({description})")
            else:
                missing_files.append((filename, description))
                logger.warning(f"‚ùå {filename} not found ({description})")

        if missing_files:
            logger.error("Missing required files:")
            for filename, desc in missing_files:
                logger.error(f"  - {filename}: {desc}")
            return False
        return True

    def start_backend(self):
        """Start the FastAPI backend server"""
        logger.info("üîß Starting AI backend server...")
        try:
            self.backend_process = subprocess.Popen([
                sys.executable, "-m", "uvicorn", "main:app",
                "--host", "0.0.0.0", "--port", "8000", "--reload"
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            # Wait a bit and check if process started successfully
            time.sleep(2)
            if self.backend_process.poll() is None:
                logger.info("‚úÖ Backend server started successfully on port 8000")
                return True
            else:
                stdout, stderr = self.backend_process.communicate()
                logger.error(f"‚ùå Backend failed to start: {stderr}")
                return False

        except Exception as e:
            logger.error(f"‚ùå Failed to start backend: {e}")
            return False

    def start_frontend(self):
        """Start the Streamlit frontend"""
        logger.info("üé® Starting Streamlit frontend...")
        try:
            self.frontend_process = subprocess.Popen([
                sys.executable, "-m", "streamlit", "run", "app.py",
                "--server.port", "8501", "--server.headless", "true"
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            time.sleep(3)
            if self.frontend_process.poll() is None:
                logger.info("‚úÖ Frontend server started successfully on port 8501")
                return True
            else:
                stdout, stderr = self.frontend_process.communicate()
                logger.error(f"‚ùå Frontend failed to start: {stderr}")
                return False

        except Exception as e:
            logger.error(f"‚ùå Failed to start frontend: {e}")
            return False

    def open_browser(self):
        """Open the browser after a delay"""

        def browser_opener():
            time.sleep(8)  # Give servers time to fully start
            try:
                webbrowser.open("http://localhost:8501")
                logger.info("üåê Browser opened to http://localhost:8501")
            except Exception as e:
                logger.warning(f"Could not open browser automatically: {e}")
                logger.info("Please manually open http://localhost:8501 in your browser")

        threading.Thread(target=browser_opener, daemon=True).start()

    def health_check(self):
        """Perform health check on both services"""
        import requests

        # Check backend
        try:
            response = requests.get("http://localhost:8000/health", timeout=5)
            if response.status_code == 200:
                logger.info("‚úÖ Backend health check passed")
            else:
                logger.warning(f"‚ö†Ô∏è Backend health check failed with status {response.status_code}")
        except requests.exceptions.RequestException as e:
            logger.warning(f"‚ö†Ô∏è Backend health check failed: {e}")

        # Check frontend (basic connection test)
        try:
            response = requests.get("http://localhost:8501", timeout=5)
            if response.status_code == 200:
                logger.info("‚úÖ Frontend is accessible")
            else:
                logger.info("‚ÑπÔ∏è Frontend is starting up...")
        except requests.exceptions.RequestException:
            logger.info("‚ÑπÔ∏è Frontend is starting up...")

    def cleanup(self):
        """Clean up processes"""
        logger.info("üßπ Cleaning up processes...")

        if self.backend_process:
            try:
                self.backend_process.terminate()
                self.backend_process.wait(timeout=5)
                logger.info("‚úÖ Backend process terminated")
            except subprocess.TimeoutExpired:
                self.backend_process.kill()
                logger.info("üî™ Backend process killed")
            except Exception as e:
                logger.error(f"Error terminating backend: {e}")

        if self.frontend_process:
            try:
                self.frontend_process.terminate()
                self.frontend_process.wait(timeout=5)
                logger.info("‚úÖ Frontend process terminated")
            except subprocess.TimeoutExpired:
                self.frontend_process.kill()
                logger.info("üî™ Frontend process killed")
            except Exception as e:
                logger.error(f"Error terminating frontend: {e}")

    def signal_handler(self, signum, frame):
        """Handle system signals for graceful shutdown"""
        logger.info("üõë Shutdown signal received")
        self.running = False
        self.cleanup()
        sys.exit(0)

    def run_system(self):
        """Main system runner"""
        # Set up signal handlers
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)

        logger.info("üöÄ Starting AI Medical Prescription Verification System...")
        logger.info("=" * 60)

        # Step 1: Check dependencies
        logger.info("Step 1: Checking dependencies...")
        if not self.check_dependencies():
            logger.error("‚ùå Dependency check failed. Exiting.")
            return False

        # Step 2: Check files
        logger.info("Step 2: Checking required files...")
        if not self.check_files():
            logger.error("‚ùå File check failed. Please ensure main.py and app.py exist.")
            return False

        # Step 3: Start backend
        logger.info("Step 3: Starting backend server...")
        if not self.start_backend():
            logger.error("‚ùå Backend startup failed. Exiting.")
            return False

        # Step 4: Start frontend
        logger.info("Step 4: Starting frontend server...")
        if not self.start_frontend():
            logger.error("‚ùå Frontend startup failed.")
            self.cleanup()
            return False

        # Step 5: Open browser
        logger.info("Step 5: Opening browser...")
        self.open_browser()

        # Step 6: Health check
        logger.info("Step 6: Performing health checks...")
        time.sleep(5)
        self.health_check()

        # Keep running and monitor
        logger.info("=" * 60)
        logger.info("üéâ System started successfully!")
        logger.info("üåê Frontend: http://localhost:8501")
        logger.info("üîß Backend API: http://localhost:8000")
        logger.info("üìñ API Docs: http://localhost:8000/docs")
        logger.info("Press Ctrl+C to stop the system")
        logger.info("=" * 60)

        try:
            while self.running:
                # Monitor processes
                if self.backend_process and self.backend_process.poll() is not None:
                    logger.error("‚ùå Backend process died unexpectedly")
                    break

                if self.frontend_process and self.frontend_process.poll() is not None:
                    logger.error("‚ùå Frontend process died unexpectedly")
                    break

                time.sleep(5)

        except KeyboardInterrupt:
            logger.info("üõë Keyboard interrupt received")
        finally:
            self.cleanup()

        return True


# ==================== TROUBLESHOOTING GUIDE ====================

def print_troubleshooting_guide():
    """Print comprehensive troubleshooting guide"""
    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    TROUBLESHOOTING GUIDE                         ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                                  ‚ïë
‚ïë üîç COMMON ISSUES AND SOLUTIONS:                                 ‚ïë
‚ïë                                                                  ‚ïë
‚ïë 1. "ModuleNotFoundError" - Missing Dependencies                  ‚ïë
‚ïë    Solution: Run 'pip install fastapi uvicorn streamlit         ‚ïë
‚ïë              requests pandas plotly pydantic'                    ‚ïë
‚ïë                                                                  ‚ïë
‚ïë 2. "Port already in use" - Ports 8000/8501 occupied             ‚ïë
‚ïë    Solution: Kill processes using those ports or change ports    ‚ïë
‚ïë    Command: netstat -tulnp | grep :8000                          ‚ïë
‚ïë             kill -9 <process_id>                                 ‚ïë
‚ïë                                                                  ‚ïë
‚ïë 3. "Connection refused" - Backend not responding                 ‚ïë
‚ïë    Solution: Check if main.py exists and uvicorn is installed    ‚ïë
‚ïë    Manual start: uvicorn main:app --reload --port 8000          ‚ïë
‚ïë                                                                  ‚ïë
‚ïë 4. "Streamlit not found" - Streamlit not installed              ‚ïë
‚ïë    Solution: pip install streamlit                               ‚ïë
‚ïë    Manual start: streamlit run app.py                           ‚ïë
‚ïë                                                                  ‚ïë
‚ïë 5. API validation errors - Data format issues                   ‚ïë
‚ïë    Solution: Check input data format and drug names             ‚ïë
‚ïë    Debug: Check browser developer tools for API responses       ‚ïë
‚ïë                                                                  ‚ïë
‚ïë 6. Slow performance - Large payload or processing               ‚ïë
‚ïë    Solution: Reduce number of drugs or simplify text            ‚ïë
‚ïë    Check: API timeout settings (currently 30 seconds)           ‚ïë
‚ïë                                                                  ‚ïë
‚ïë üîß DEBUG MODE:                                                  ‚ïë
‚ïë    Set logging level to DEBUG for more information              ‚ïë
‚ïë    Add print statements in analysis functions                   ‚ïë
‚ïë    Check browser console for JavaScript errors                  ‚ïë
‚ïë                                                                  ‚ïë
‚ïë üìã FILE STRUCTURE CHECK:                                        ‚ïë
‚ïë    ‚îú‚îÄ‚îÄ main.py          (FastAPI backend)                       ‚ïë
‚ïë    ‚îú‚îÄ‚îÄ app.py           (Streamlit frontend)                    ‚ïë
‚ïë    ‚îú‚îÄ‚îÄ debug_and_run.py (This script)                          ‚ïë
‚ïë    ‚îî‚îÄ‚îÄ requirements.txt (Optional dependencies list)           ‚ïë
‚ïë                                                                  ‚ïë
‚ïë üÜò EMERGENCY MANUAL START:                                      ‚ïë
‚ïë    Terminal 1: uvicorn main:app --reload --port 8000           ‚ïë
‚ïë    Terminal 2: streamlit run app.py --server.port 8501         ‚ïë
‚ïë                                                                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)


# Main execution
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="AI Medical Prescription System Manager")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode")
    parser.add_argument("--help-troubleshoot", action="store_true", help="Show troubleshooting guide")
    parser.add_argument("--check-only", action="store_true", help="Only check dependencies and files")

    args = parser.parse_args()

    if args.help_troubleshoot:
        print_troubleshooting_guide()
        sys.exit(0)

    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)

    manager = SystemManager()

    if args.check_only:
        logger.info("üîç Performing system checks only...")
        deps_ok = manager.check_dependencies()
        files_ok = manager.check_files()

        if deps_ok and files_ok:
            logger.info("‚úÖ All checks passed! System ready to run.")
            sys.exit(0)
        else:
            logger.error("‚ùå System checks failed. See messages above.")
            sys.exit(1)
    else:
        success = manager.run_system()
        sys.exit(0 if success else 1)


